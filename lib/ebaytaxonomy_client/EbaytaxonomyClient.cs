// Code generated by Microsoft (R) AutoRest Code Generator 0.16.0.0
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

namespace ebaytaxonomy
{
    using System;
    using System.Collections.Generic;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Newtonsoft.Json;
    using Models;

    /// <summary>
    /// Use the Taxonomy API to discover the most appropriate eBay categories
    /// under which sellers can offer inventory items for sale, and the most
    /// likely categories under which buyers can browse or search for items
    /// to purchase. In addition, the Taxonomy API provides metadata about
    /// the required and recommended category aspects to include in listings,
    /// and also has two operations to retrieve parts compatibility
    /// information.
    /// </summary>
    public partial class EbaytaxonomyClient : ServiceClient<EbaytaxonomyClient>, IEbaytaxonomyClient
    {
        /// <summary>
        /// The base URI of the service.
        /// </summary>
        public Uri BaseUri { get; set; }

        /// <summary>
        /// Gets or sets json serialization settings.
        /// </summary>
        public JsonSerializerSettings SerializationSettings { get; private set; }

        /// <summary>
        /// Gets or sets json deserialization settings.
        /// </summary>
        public JsonSerializerSettings DeserializationSettings { get; private set; }        

        /// <summary>
        /// Subscription credentials which uniquely identify client subscription.
        /// </summary>
        public ServiceClientCredentials Credentials { get; private set; }

        /// <summary>
        /// Initializes a new instance of the EbaytaxonomyClient class.
        /// </summary>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        protected EbaytaxonomyClient(params DelegatingHandler[] handlers) : base(handlers)
        {
            this.Initialize();
        }

        /// <summary>
        /// Initializes a new instance of the EbaytaxonomyClient class.
        /// </summary>
        /// <param name='rootHandler'>
        /// Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        protected EbaytaxonomyClient(HttpClientHandler rootHandler, params DelegatingHandler[] handlers) : base(rootHandler, handlers)
        {
            this.Initialize();
        }

        /// <summary>
        /// Initializes a new instance of the EbaytaxonomyClient class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        protected EbaytaxonomyClient(Uri baseUri, params DelegatingHandler[] handlers) : this(handlers)
        {
            if (baseUri == null)
            {
                throw new ArgumentNullException("baseUri");
            }
            this.BaseUri = baseUri;
        }

        /// <summary>
        /// Initializes a new instance of the EbaytaxonomyClient class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='rootHandler'>
        /// Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        protected EbaytaxonomyClient(Uri baseUri, HttpClientHandler rootHandler, params DelegatingHandler[] handlers) : this(rootHandler, handlers)
        {
            if (baseUri == null)
            {
                throw new ArgumentNullException("baseUri");
            }
            this.BaseUri = baseUri;
        }

        /// <summary>
        /// Initializes a new instance of the EbaytaxonomyClient class.
        /// </summary>
        /// <param name='credentials'>
        /// Required. Subscription credentials which uniquely identify client subscription.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        public EbaytaxonomyClient(ServiceClientCredentials credentials, params DelegatingHandler[] handlers) : this(handlers)
        {
            if (credentials == null)
            {
                throw new ArgumentNullException("credentials");
            }
            this.Credentials = credentials;
            if (this.Credentials != null)
            {
                this.Credentials.InitializeServiceClient(this);
            }
        }

        /// <summary>
        /// Initializes a new instance of the EbaytaxonomyClient class.
        /// </summary>
        /// <param name='credentials'>
        /// Required. Subscription credentials which uniquely identify client subscription.
        /// </param>
        /// <param name='rootHandler'>
        /// Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        public EbaytaxonomyClient(ServiceClientCredentials credentials, HttpClientHandler rootHandler, params DelegatingHandler[] handlers) : this(rootHandler, handlers)
        {
            if (credentials == null)
            {
                throw new ArgumentNullException("credentials");
            }
            this.Credentials = credentials;
            if (this.Credentials != null)
            {
                this.Credentials.InitializeServiceClient(this);
            }
        }

        /// <summary>
        /// Initializes a new instance of the EbaytaxonomyClient class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='credentials'>
        /// Required. Subscription credentials which uniquely identify client subscription.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        public EbaytaxonomyClient(Uri baseUri, ServiceClientCredentials credentials, params DelegatingHandler[] handlers) : this(handlers)
        {
            if (baseUri == null)
            {
                throw new ArgumentNullException("baseUri");
            }
            if (credentials == null)
            {
                throw new ArgumentNullException("credentials");
            }
            this.BaseUri = baseUri;
            this.Credentials = credentials;
            if (this.Credentials != null)
            {
                this.Credentials.InitializeServiceClient(this);
            }
        }

        /// <summary>
        /// Initializes a new instance of the EbaytaxonomyClient class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='credentials'>
        /// Required. Subscription credentials which uniquely identify client subscription.
        /// </param>
        /// <param name='rootHandler'>
        /// Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        public EbaytaxonomyClient(Uri baseUri, ServiceClientCredentials credentials, HttpClientHandler rootHandler, params DelegatingHandler[] handlers) : this(rootHandler, handlers)
        {
            if (baseUri == null)
            {
                throw new ArgumentNullException("baseUri");
            }
            if (credentials == null)
            {
                throw new ArgumentNullException("credentials");
            }
            this.BaseUri = baseUri;
            this.Credentials = credentials;
            if (this.Credentials != null)
            {
                this.Credentials.InitializeServiceClient(this);
            }
        }

        /// <summary>
        /// An optional partial-method to perform custom initialization.
        ///</summary> 
        partial void CustomInitialize();
        /// <summary>
        /// Initializes client properties.
        /// </summary>
        private void Initialize()
        {
            this.BaseUri = new Uri("https://api.ebay.com/commerce/taxonomy/v1_beta");
            SerializationSettings = new JsonSerializerSettings
            {
                Formatting = Formatting.Indented,
                DateFormatHandling = DateFormatHandling.IsoDateFormat,
                DateTimeZoneHandling = DateTimeZoneHandling.Utc,
                NullValueHandling = NullValueHandling.Ignore,
                ReferenceLoopHandling = ReferenceLoopHandling.Serialize,
                ContractResolver = new ReadOnlyJsonContractResolver(),
                Converters = new List<JsonConverter>
                    {
                        new Iso8601TimeSpanConverter()
                    }
            };
            DeserializationSettings = new JsonSerializerSettings
            {
                DateFormatHandling = DateFormatHandling.IsoDateFormat,
                DateTimeZoneHandling = DateTimeZoneHandling.Utc,
                NullValueHandling = NullValueHandling.Ignore,
                ReferenceLoopHandling = ReferenceLoopHandling.Serialize,
                ContractResolver = new ReadOnlyJsonContractResolver(),
                Converters = new List<JsonConverter>
                    {
                        new Iso8601TimeSpanConverter()
                    }
            };
            CustomInitialize();
        }    
        /// <summary>
        /// Get a Default Category Tree ID
        /// </summary>
        /// A given eBay marketplace might use multiple category trees, but one of
        /// those trees is considered to be the default for that marketplace. This
        /// call retrieves a reference to the default category tree associated with
        /// the specified eBay marketplace ID. The response includes only the tree's
        /// unique identifier and version, which you can use to retrieve more details
        /// about the tree, its structure, and its individual category nodes.
        /// <param name='marketplaceId'>
        /// The ID of the eBay marketplace for which the category tree ID is being
        /// requested. For a list of supported marketplace IDs, see Marketplaces with
        /// Default Category Trees.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<BaseCategoryTree>> GetDefaultCategoryTreeIdWithHttpMessagesAsync(string marketplaceId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (marketplaceId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "marketplaceId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("marketplaceId", marketplaceId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetDefaultCategoryTreeId", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "get_default_category_tree_id").ToString();
            List<string> _queryParameters = new List<string>();
            if (marketplaceId != null)
            {
                _queryParameters.Add(string.Format("marketplace_id={0}", Uri.EscapeDataString(marketplaceId)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 204 && (int)_statusCode != 400 && (int)_statusCode != 500)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<BaseCategoryTree>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<BaseCategoryTree>(_responseContent, this.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Get a Category Tree
        /// </summary>
        /// This call retrieves the complete category tree that is identified by the
        /// category_tree_id parameter. The value of category_tree_id was returned by
        /// the getDefaultCategoryTreeId call in the categoryTreeId field. The
        /// response contains details of all nodes of the specified eBay category
        /// tree, as well as the eBay marketplaces that use this category tree. Note:
        /// This call can return a very large payload, so you are strongly advised to
        /// submit the request with the following HTTP header:
        /// &amp;nbsp;&amp;nbsp;Accept-Encoding: application/gzip With this header
        /// (in addition to the required headers described under HTTP Request
        /// Headers), the call returns the response with gzip compression.
        /// <param name='categoryTreeId'>
        /// The unique identifier of the eBay category tree being requested.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<CategoryTree>> GetCategoryTreeWithHttpMessagesAsync(string categoryTreeId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (categoryTreeId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "categoryTreeId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("categoryTreeId", categoryTreeId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetCategoryTree", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "category_tree/{category_tree_id}").ToString();
            _url = _url.Replace("{category_tree_id}", Uri.EscapeDataString(categoryTreeId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 404 && (int)_statusCode != 500)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<CategoryTree>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<CategoryTree>(_responseContent, this.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Get a Category Subtree
        /// </summary>
        /// This call retrieves the details of all nodes of the category tree
        /// hierarchy (the subtree) below a specified category of a category tree.
        /// You identify the tree using the category_tree_id parameter, which was
        /// returned by the getDefaultCategoryTreeId call in the categoryTreeId
        /// field. Note: This call can return a very large payload, so you are
        /// strongly advised to submit the request with the following HTTP header:
        /// &amp;nbsp;&amp;nbsp;Accept-Encoding: application/gzip With this header
        /// (in addition to the required headers described under HTTP Request
        /// Headers), the call returns the response with gzip compression.
        /// <param name='categoryId'>
        /// The unique identifier of the category at the top of the subtree being
        /// requested. Note: If the category_id submitted identifies the root node of
        /// the tree, this call returns an error. To retrieve the complete tree, use
        /// this value with the getCategoryTree call. If the category_id submitted
        /// identifies a leaf node of the tree, the call response will contain
        /// information about only that leaf node, which is a valid subtree.
        /// </param>
        /// <param name='categoryTreeId'>
        /// The unique identifier of the eBay category tree from which a category
        /// subtree is being requested.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<CategorySubtree>> GetCategorySubtreeWithHttpMessagesAsync(string categoryId, string categoryTreeId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (categoryId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "categoryId");
            }
            if (categoryTreeId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "categoryTreeId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("categoryId", categoryId);
                tracingParameters.Add("categoryTreeId", categoryTreeId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetCategorySubtree", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "category_tree/{category_tree_id}/get_category_subtree").ToString();
            _url = _url.Replace("{category_tree_id}", Uri.EscapeDataString(categoryTreeId));
            List<string> _queryParameters = new List<string>();
            if (categoryId != null)
            {
                _queryParameters.Add(string.Format("category_id={0}", Uri.EscapeDataString(categoryId)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 404 && (int)_statusCode != 500)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<CategorySubtree>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<CategorySubtree>(_responseContent, this.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Get Suggested Categories
        /// </summary>
        /// This call returns an array of category tree leaf nodes in the specified
        /// category tree that are considered by eBay to most closely correspond to
        /// the query string q. Returned with each suggested node is a localized name
        /// for that category (based on the Accept-Language header specified for the
        /// call), and details about each of the category's ancestor nodes, extending
        /// from its immediate parent up to the root of the category tree. Note: This
        /// call can return a large payload, so you are advised to submit the request
        /// with the following HTTP header: &amp;nbsp;&amp;nbsp;Accept-Encoding:
        /// application/gzip With this header (in addition to the required headers
        /// described under HTTP Request Headers), the call returns the response with
        /// gzip compression. You identify the tree using the category_tree_id
        /// parameter, which was returned by the getDefaultCategoryTreeId call in the
        /// categoryTreeId field. Important: This call is not supported in the
        /// Sandbox environment. It will return a response payload in which the
        /// categoryName fields contain random or boilerplate text regardless of the
        /// query submitted.
        /// <param name='categoryTreeId'>
        /// The unique identifier of the eBay category tree for which suggested nodes
        /// are being requested.
        /// </param>
        /// <param name='q'>
        /// A quoted string that describes or characterizes the item being offered for
        /// sale. The string format is free form, and can contain any combination of
        /// phrases or keywords. eBay will parse the string and return suggested
        /// categories for the item.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<CategorySuggestionResponse>> GetCategorySuggestionsWithHttpMessagesAsync(string categoryTreeId, string q, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (categoryTreeId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "categoryTreeId");
            }
            if (q == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "q");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("categoryTreeId", categoryTreeId);
                tracingParameters.Add("q", q);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetCategorySuggestions", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "category_tree/{category_tree_id}/get_category_suggestions").ToString();
            _url = _url.Replace("{category_tree_id}", Uri.EscapeDataString(categoryTreeId));
            List<string> _queryParameters = new List<string>();
            if (q != null)
            {
                _queryParameters.Add(string.Format("q={0}", Uri.EscapeDataString(q)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 204 && (int)_statusCode != 400 && (int)_statusCode != 404 && (int)_statusCode != 500)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<CategorySuggestionResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<CategorySuggestionResponse>(_responseContent, this.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// This call returns a list of aspects that are appropriate or necessary for
        /// accurately describing items in the specified leaf category. Each aspect
        /// identifies an item attribute (for example, color) for which the seller
        /// will be required or encouraged to provide a value (or variation values)
        /// when offering an item in that category on eBay. For each aspect,
        /// getItemAspectsForCategory provides complete metadata, including: The
        /// aspect's data type, format, and entry mode Whether the aspect is required
        /// in listings Whether the aspect can be used for item variations Whether
        /// the aspect accepts multiple values for an item Allowed values for the
        /// aspect Use this information to construct an interface through which
        /// sellers can enter or select the appropriate values for their items or
        /// item variations. Once you collect those values, include them as product
        /// aspects when creating inventory items using the Inventory API.
        /// </summary>
        /// <param name='categoryId'>
        /// The unique identifier of the leaf category for which aspects are being
        /// requested. Note: If the category_id submitted does not identify a leaf
        /// node of the tree, this call returns an error.
        /// </param>
        /// <param name='categoryTreeId'>
        /// The unique identifier of the eBay category tree from which the specified
        /// category's aspects are being requested.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<AspectMetadata>> GetItemAspectsForCategoryWithHttpMessagesAsync(string categoryId, string categoryTreeId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (categoryId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "categoryId");
            }
            if (categoryTreeId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "categoryTreeId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("categoryId", categoryId);
                tracingParameters.Add("categoryTreeId", categoryTreeId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetItemAspectsForCategory", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "category_tree/{category_tree_id}/get_item_aspects_for_category").ToString();
            _url = _url.Replace("{category_tree_id}", Uri.EscapeDataString(categoryTreeId));
            List<string> _queryParameters = new List<string>();
            if (categoryId != null)
            {
                _queryParameters.Add(string.Format("category_id={0}", Uri.EscapeDataString(categoryId)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 204 && (int)_statusCode != 400 && (int)_statusCode != 404 && (int)_statusCode != 500)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<AspectMetadata>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<AspectMetadata>(_responseContent, this.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Get Compatibility Properties
        /// </summary>
        /// This call retrieves the compatible vehicle aspects that are used to define
        /// a motor vehicle that is compatible with a motor vehicle part or
        /// accessory. The values that are retrieved here might include motor vehicle
        /// aspects such as 'Make', 'Model', 'Year', 'Engine', and 'Trim', and each
        /// of these aspects are localized for the eBay marketplace. The
        /// category_tree_id value is passed in as a path parameter, and this value
        /// identifies the eBay category tree. The category_id value is passed in as
        /// a query parameter, as this parameter is also required. The specified
        /// category must be a category that supports parts compatibility. At this
        /// time, this operation only supports parts and accessories listings for
        /// cars, trucks, and motorcycles (not boats, power sports, or any other
        /// vehicle types). Only the following eBay marketplaces support parts
        /// compatibility: eBay US (Motors and non-Motors categories) eBay Canada
        /// (Motors and non-Motors categories) eBay UK eBay Germany eBay Australia
        /// eBay France eBay Italy eBay Spain
        /// <param name='categoryTreeId'>
        /// This is the unique identifier of category tree. The following is the list
        /// of category_tree_id values and the eBay marketplaces that they represent.
        /// One of these ID values must be passed in as a path parameter, and the
        /// category_id value, that is passed in as query parameter, must be a valid
        /// eBay category on that eBay marketplace that supports parts compatibility
        /// for cars, trucks, or motorcyles. eBay US: 0 eBay Motors US: 100 eBay
        /// Canada: 2 eBay UK: 3 eBay Germany: 77 eBay Australia: 15 eBay France: 71
        /// eBay Italy: 101 eBay Spain: 186
        /// </param>
        /// <param name='categoryId'>
        /// The unique identifier of an eBay category. This eBay category must be a
        /// valid eBay category on the specified eBay marketplace, and the category
        /// must support parts compatibility for cars, trucks, or motorcyles. The
        /// getAutomotivePartsCompatibilityPolicies method of the Selling Metadata
        /// API can be used to retrieve all eBay categories for an eBay marketplace
        /// that supports parts compatibility cars, trucks, or motorcyles. The
        /// getAutomotivePartsCompatibilityPolicies method can also be used to see if
        /// one or more specific eBay categories support parts compatibility.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<GetCompatibilityMetadataResponse>> GetCompatibilityPropertiesWithHttpMessagesAsync(string categoryTreeId, string categoryId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (categoryTreeId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "categoryTreeId");
            }
            if (categoryId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "categoryId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("categoryTreeId", categoryTreeId);
                tracingParameters.Add("categoryId", categoryId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetCompatibilityProperties", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "category_tree/{category_tree_id}/get_compatibility_properties").ToString();
            _url = _url.Replace("{category_tree_id}", Uri.EscapeDataString(categoryTreeId));
            List<string> _queryParameters = new List<string>();
            if (categoryId != null)
            {
                _queryParameters.Add(string.Format("category_id={0}", Uri.EscapeDataString(categoryId)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 204 && (int)_statusCode != 400 && (int)_statusCode != 404 && (int)_statusCode != 500)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<GetCompatibilityMetadataResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<GetCompatibilityMetadataResponse>(_responseContent, this.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Get Compatibility Property Values
        /// </summary>
        /// This call retrieves applicable compatible vehicle property values based on
        /// the specified eBay marketplace, specified eBay category, and filters used
        /// in the request. Compatible vehicle properties are returned in the
        /// compatibilityProperties.name field of a getCompatibilityProperties
        /// response. One compatible vehicle property applicable to the specified
        /// eBay marketplace and eBay category is specified through the required
        /// compatibility_property filter. Then, the user has the option of further
        /// restricting the compatible vehicle property values that are returned in
        /// the response by specifying one or more compatible vehicle property
        /// name/value pairs through the filter query parameter. See the
        /// documentation in URI parameters section for more information on using the
        /// compatibility_property and filter query parameters together to customize
        /// the data that is retrieved.
        /// <param name='categoryTreeId'>
        /// This is the unique identifier of the category tree. The following is the
        /// list of category_tree_id values and the eBay marketplaces that they
        /// represent. One of these ID values must be passed in as a path parameter,
        /// and the category_id value, that is passed in as query parameter, must be
        /// a valid eBay category on that eBay marketplace that supports parts
        /// compatibility for cars, trucks, or motorcyles. eBay US: 0 eBay Motors US:
        /// 100 eBay Canada: 2 eBay UK: 3 eBay Germany: 77 eBay Australia: 15 eBay
        /// France: 71 eBay Italy: 101 eBay Spain: 186
        /// </param>
        /// <param name='compatibilityProperty'>
        /// One compatible vehicle property applicable to the specified eBay
        /// marketplace and eBay category is specified in this required filter.
        /// Compatible vehicle properties are returned in the
        /// compatibilityProperties.name field of a getCompatibilityProperties
        /// response. For example, if you wanted to retrieve all vehicle trims for a
        /// 2018 Toyota Camry, you would set this filter as follows:
        /// compatibility_property=Trim; and then include the following three
        /// name/value filters through one filter parameter:
        /// filter=Year:2018,Make:Toyota,Model:Camry. So, putting this all together,
        /// your URI would look something like this: GET
        /// https://api.ebay.com/commerce/ taxonomy/v1_beta/category_tree/100/
        /// get_compatibility_property_values?
        /// category_id=6016&amp;amp;compatibility_property=Trim
        /// &amp;amp;filter=filter=Year:2018,Make:Toyota,Model:Camry
        /// </param>
        /// <param name='categoryId'>
        /// The unique identifier of an eBay category. This eBay category must be a
        /// valid eBay category on the specified eBay marketplace, and the category
        /// must support parts compatibility for cars, trucks, or motorcyles. The
        /// getAutomotivePartsCompatibilityPolicies method of the Selling Metadata
        /// API can be used to retrieve all eBay categories for an eBay marketplace
        /// that supports parts compatibility cars, trucks, or motorcyles. The
        /// getAutomotivePartsCompatibilityPolicies method can also be used to see if
        /// one or more specific eBay categories support parts compatibility.
        /// </param>
        /// <param name='filter'>
        /// One or more compatible vehicle property name/value pairs are passed in
        /// through this query parameter. The compatible vehicle property name and
        /// corresponding value are delimited with a colon (:), such as
        /// filter=Year:2018, and multiple compatible vehicle property name/value
        /// pairs are delimited with a comma (,). For example, if you wanted to
        /// retrieve all vehicle trims for a 2018 Toyota Camry, you would set the
        /// compatibility_property filter as follows: compatibility_property=Trim;
        /// and then include the following three name/value filters through one
        /// filter parameter: filter=Year:2018,Make:Toyota,Model:Camry. So, putting
        /// this all together, your URI would look something like this: GET
        /// https://api.ebay.com/commerce/ taxonomy/v1_beta/category_tree/100/
        /// get_compatibility_property_values?
        /// category_id=6016&amp;amp;compatibility_property=Trim
        /// &amp;amp;filter=filter=Year:2018,Make:Toyota,Model:Camry For
        /// implementation help, refer to eBay API documentation at
        /// https://developer.ebay.com/devzone/rest/api-ref/taxonomy/types/ConstraintFilter.html
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<GetCompatibilityPropertyValuesResponse>> GetCompatibilityPropertyValuesWithHttpMessagesAsync(string categoryTreeId, string compatibilityProperty, string categoryId, string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (categoryTreeId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "categoryTreeId");
            }
            if (compatibilityProperty == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "compatibilityProperty");
            }
            if (categoryId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "categoryId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("categoryTreeId", categoryTreeId);
                tracingParameters.Add("compatibilityProperty", compatibilityProperty);
                tracingParameters.Add("categoryId", categoryId);
                tracingParameters.Add("filter", filter);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetCompatibilityPropertyValues", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "category_tree/{category_tree_id}/get_compatibility_property_values").ToString();
            _url = _url.Replace("{category_tree_id}", Uri.EscapeDataString(categoryTreeId));
            List<string> _queryParameters = new List<string>();
            if (compatibilityProperty != null)
            {
                _queryParameters.Add(string.Format("compatibility_property={0}", Uri.EscapeDataString(compatibilityProperty)));
            }
            if (categoryId != null)
            {
                _queryParameters.Add(string.Format("category_id={0}", Uri.EscapeDataString(categoryId)));
            }
            if (filter != null)
            {
                _queryParameters.Add(string.Format("filter={0}", Uri.EscapeDataString(filter)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 204 && (int)_statusCode != 400 && (int)_statusCode != 404 && (int)_statusCode != 500)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<GetCompatibilityPropertyValuesResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<GetCompatibilityPropertyValuesResponse>(_responseContent, this.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

    }
}
